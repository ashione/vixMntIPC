

 \subsection*{1. Introduction}

Undoubtedly, as we know, the virtual disk A\+PI, or Vix\+Disk\+Lib, is a set of function calls to manipulate virtual disk files in V\+M\+DK format (virtual machine disk). But Vix\+Disklib only offer certain functions in disk level. Actually many customers want a useful tool to manipulate file without reading or writing whole disk.

For this reason, we proposed a filesystem level tool named Vix\+Mount\+Api ( as is mountapi )that analyzes disk partition and stored file meta-\/data via Vix\+Disklib. Then users are able to open or write any files of remote V\+M\+DK and enjoy IO operations like local filestystem on linux os.

Besides, there are additional motivations \+:


\begin{DoxyEnumerate}
\item The install ratio of linux guest os has been increasing dramatically.
\end{DoxyEnumerate}
\begin{DoxyItemize}
\item With disk capacity growing, the original N\+BD mode can’t meet the requirements.
\item These advanced transport modes realize significantly performance improvements, however these are still not supported in file level. 


\end{DoxyItemize}

\subsubsection*{1.\+1 Issue}

Although mountapi have capability to mount remote V\+M\+DK or snapshot via Vix\+Disk\+Lib, a \href{https://bugzilla.eng.vmware.com/show_bug.cgi?id=1492312}{\tt bug} demonstrated that mount test on advanced transport mode ( such as nbdssl, hotadd and san) had J\+VM crash on alternate runs at Vix\+Mntapi\+\_\+\+Get\+Volume\+Handles as Vix\+Mntapi\+\_\+\+Open\+Disks does not return a valid diskset\+Handle. Some efforts have been utilized to fix this bug, but Vix\+Mntapi\+\_\+\+Open\+Disks still doesn\textquotesingle{}t return a valid diskset\+Handle.

We strive to search a constructive way to slove this problem and finally Fletcher‘s diagnostics may help us to some degree or another. \begin{DoxyVerb}As I dig into this it's all coming back to me now.  A few years ago I looked into this issue, and I concluded that no matter which transport mode is used, when the plugin is loaded, you cannot use vixMntapi on Linux.  The problem is that vmacore spawns multiple threads to do its job, and these threads to not survive across a fork.  This means that the spawned process is broken and cannot function correctly.  This is why we put a fix into the Linux version of vixMntapi.  The fix causes an error for vixMntapi on Linux for any transport mode including nbd when the plugin is loaded.
\end{DoxyVerb}


Based on above investigates, we summarize that

$<$font color=\char`\"{}red\char`\"{}$>$$\ast$$\ast$the fork subprocess libfuse can\textquotesingle{}t connect vmdk disk when the plugin is loaded because vmacore spawns multiple threads are isolated from \href{https://github.com/libfuse/libfuse}{\tt libfuse} read and write callback.$\ast$$\ast$$<$/font$>$ 

 \subsubsection*{1.\+2 Solutions}

Firstly, it\textquotesingle{}s necessary to review original metric and entire workflow can be descirbed as ths following image. !\mbox{[}image\mbox{]}\mbox{[}mntapi\mbox{]}

From above samplecode workflow, we know libfuse is empolyed by mountapi. ({\itshape F\+U\+SE (Filesystem in Userspace) is an interface for userspace programs to export a filesystem to the Linux kernel.})

When advcanced transport mode is applied, vmacore initialize and produce multiple threads in vix\+Disk\+Lib initializition phase if dislibplugin is loaded successfully. After that, Vix\+Disklib try to open target V\+M\+DK and return its vix\+Diskhandle that is indispensable for followed other operations. Unfortunately, fusemount will fork a process, but father process step into infinite waiting because that can\textquotesingle{}t open or connect target VM to initialize libfuse configurations. Finally, all of them are stagnating.

According this failure, we drafted three solutions\+:


\begin{DoxyEnumerate}
\item open vixdisklib or initalize vmacore spawns multiply threads after fusedaemon. !\mbox{[}union\+\_\+mode\mbox{]}\mbox{[}union\+\_\+mode\mbox{]}
\end{DoxyEnumerate}
\begin{DoxyItemize}
\item use multithread instead of multiprocess forked by fusemount. !\mbox{[}multithread\+\_\+mntapi\mbox{]}\mbox{[}multithread\+\_\+mntapi\mbox{]}
\item setup share memory or global message based on I\+PC ( inner process communication) !\mbox{[}processcom\mbox{]}\mbox{[}processcom\mbox{]}
\end{DoxyItemize}

All these solutions look like good designs at first appearance. However, postponed vmacore (1) initialization and multiply threads metric (2) replacing forked multiply process cannot bear closer analysis. Generally speaking, these disadvantages cancel their possibility as final model\+:


\begin{DoxyItemize}
\item vixdisklib programming guideline suggestes users to connect/open V\+M\+D\+K/disk at first. Besides, vixdisklib/vixmntapi only export interfaces to customers rather than change users\textquotesingle{} pace. ( vs. 1 )
\item parameters adjustment of A\+PI will make users confused among different versions in short time. (vs. 1)
\item libfuse will fork inside, which is not depended on our control.(vs. 2)
\item its design limits programmer and imposes more restrictions on extension. (vs. 2)
\end{DoxyItemize}

$<$font color=\char`\"{}blue\char`\"{}$>$$\ast$$\ast$\+Hence, solution 3 is chosed finnally.$\ast$$\ast$$<$/font$>$ 

 \subsection*{2. Overview of fusemount\+I\+PC}

As we know, vmacore threads have been created at beginning, which make waiting fuse initialization function hanging out here. To slove above problem, note that we define some class objects \+:


\begin{DoxyItemize}
\item {\bfseries vix\+Mnt\+Disk\+Handle}\+:`\+It can open a disk and does IO operations by passing disk\+Handle parameter. Moreover, a permanent thread will be invoked for listening to system messages. Then, according different message type, listen thread should call a proper handle function.{\ttfamily }
\item {\ttfamily $\ast$$\ast$vix\+Mnt\+Mmap$\ast$$\ast$\+:}Packaged share memory for data path by memory map.{\ttfamily }
\item {\ttfamily $\ast$$\ast$vix\+Mnt\+Msg\+Que$\ast$$\ast$\+:}Packaged message queue for control path`
\item {\bfseries vix\+Mnt\+Msg\+Op}\+:{\ttfamily Enum class, these message types include Mnt\+Read,Mnt\+Read\+Done,Mnt\+Write,Mnt\+Write\+Done and so on. A object of this class will be shipped from sender to receiver by message queue.}
\item {\bfseries vix\+Mnt\+Operation}\+:{\ttfamily Operations consist of read and write parameters needed by libfuse.}
\item {\bfseries vix\+Mnt\+Utility}\+:{\ttfamily Export interface to bottom layer. ( Initialization, Main handle function, clear function)}
\item {\bfseries vix\+Mnt\+Socket}\+:{\ttfamily The other metric differs from the solution about data tranposort by share memory}
\item {\bfseries vix\+Mnt\+Fuse}\+:{\ttfamily Entry point for libfuse callback.}
\item {\bfseries vix\+Mnt\+Lock\&vix\+Mnt\+Exception}\+: {\ttfamily Specific lock \& exception class}
\end{DoxyItemize}

From the system perspective, we abstract the middleware (fuse daemon) as core communication layer from different modules, for which data control layer is able to focus on message passing. So that new features can be added easily.

By fusemount I\+PC module, we divide whole work into four principal components and its detail can be depcited as \+:

!\mbox{[}fuse\+I\+P\+C\+\_\+timeline\mbox{]}\mbox{[}fuse\+I\+P\+C\+\_\+timeline\mbox{]}

Frankly speaking, we modify the part of original fusemount module since the passed conncetion is invalid so that it\textquotesingle{}s out of connection in fuse daemon. According this status, read/write operation functions are only design to send a nofitication instead of real disk IO. As shown above figure, a new module are proposed to connect remote disk, do some IO operations, lookup files in mounted disk and so on.

Additionally, it\textquotesingle{}s worth mentioning that a special class vix\+Mnt\+Operation, described as message protocol, is stored in buffer stream. In other word, a libfuse notification was serialized as message buffer, then deserialized to class object after receiving notification by I\+PC module. Actually, both socket and message queue are supported in this module.

The framwork can be described as follwing graph\+: !\mbox{[}fusemount\+I\+PC\mbox{]}\mbox{[}fusemount\+I\+PC\mbox{]}

And its flow chart is \+:

!\mbox{[}fuse\mbox{]}\mbox{[}fuse\mbox{]}



 \subsection*{3. How to slove the problem Device busy or abnormally umount}


\begin{DoxyEnumerate}
\item Using {\ttfamily umount mountpoint} can umount the mountpoint in temp directory
\item Then, {\ttfamily fusermount -\/u mountpoint} will disable fuse virtual device, which make sure our mount process normally re-\/run without reboot the proxy OS.

{\itshape but the mointpoint in $<$font color=\char`\"{}red\char`\"{}$>$\+\_\+\+\_\+/temp\+\_\+\+\_\+$<$/font$>$ differ from mounpoint in $<$font color=\char`\"{}red\char`\"{}$>$\+\_\+\+\_\+/var/run/vmware/fuse\+\_\+\+\_\+$<$/font$>$}
\end{DoxyEnumerate}
\begin{DoxyItemize}
\item Actually, the way doing above may not work sometimes. 


\end{DoxyItemize}

\subsection*{4. Experimental Results}

\subsubsection*{4.\+1 Log informations}

\subparagraph*{2016-\/06-\/29}

proxy OS $\vert$ target OS $\vert$ disk format $\vert$ transport mode $\vert$result -\/---$\vert$-\/-\/-\/---$\vert$-\/--- R\+H\+E\+L6.\+6 $\vert$ Ubuntu\+Thin\+Lin $\vert$ ext2,ext3,ext4 $\vert$ nbd,nbdssl,hostadd $\vert$ $<$font color=\char`\"{}green\char`\"{}$>$Y\+ES$<$/font$>$ R\+H\+E\+L6.\+6 $\vert$ R\+H\+E\+L6.\+6 (mount self) $\vert$ ext2,ext3,ext4 $\vert$ nbd,nbdssl $\vert$ $<$font color=\char`\"{}\+Green\char`\"{}$>$Y\+ES$<$/font$>$

\subparagraph*{2016-\/06-\/28}

proxy OS $\vert$ target OS $\vert$ disk format $\vert$ transport mode $\vert$result -\/---$\vert$-\/-\/-\/---$\vert$-\/--- R\+H\+E\+L6.\+6 $\vert$ Ubuntu\+Thin\+Lin $\vert$ ext2,ext4 $\vert$ nbd,nbdssl,hostadd $\vert$ $<$font color=\char`\"{}green\char`\"{}$>$Y\+ES$<$/font$>$ R\+H\+E\+L6.\+6 $\vert$ Ubuntu\+Thin\+Lin $\vert$ ext3 $\vert$ nbd,nbdssl,hotadd$\vert$ $<$font color=\char`\"{}red\char`\"{}$>$NO$<$/font$>$ R\+H\+E\+L6.\+6 $\vert$ R\+H\+E\+L6.\+6 (mount self) $\vert$ ext2,ext4 $\vert$ nbd,nbdssl $\vert$ $<$font color=\char`\"{}\+Green\char`\"{}$>$Y\+ES$<$/font$>$ R\+H\+E\+L6.\+6 $\vert$ R\+H\+E\+L6.\+6 (mount self) $\vert$ ext3 $\vert$ nbd,nbdssl,hotadd$\vert$ $<$font color=\char`\"{}red\char`\"{}$>$NO$<$/font$>$ \begin{DoxyVerb}warning: command line show the following error msg :
mount: wrong fs type, bad option, bad superblock on /dev/loop0,
   missing codepage or helper program, or other error
   In some cases useful info is found in syslog - try
   dmesg | tail  or so

which means proxy OS can't recognize the disk format on target OS.
\end{DoxyVerb}



\begin{DoxyItemize}
\item $\sim$$\sim$\+The function only mount the last paritition in the disk even though entire process go throught all checks$\sim$$\sim$.
\item Mount function isn\textquotesingle{}t able to find target OS System participation (/root), but work in other disks.
\end{DoxyItemize}

\subsubsection*{4.\+2 Conclusion}


\begin{DoxyItemize}
\item {\bfseries $<$font color=\char`\"{}red\char`\"{}$>$The reason of why this function didn\textquotesingle{}t work is our target OS in testbed install system on L\+VM.$<$/font$>$}
\end{DoxyItemize}

\subsubsection*{4.\+3 Future works}

The proposed solution and its implementation fullfill the mount api in advanced transport mode. Nevertheless it still does\textquotesingle{}t work on L\+VM. In addition, the solution about share memory is dependent on proxy memory size. All of its shortages and problems of this solution, we should face and devise a better method to deal with.

\subsection*{5. Reference}


\begin{DoxyEnumerate}
\item \mbox{[}bugid\mbox{]} (\char`\"{}https\+://bugzilla.\+eng.\+vmware.\+com/show\+\_\+bug.\+cgi?id=1492312\char`\"{})
\item \mbox{[}mntapi\mbox{]}\+: mntapi.\+png =600
\item \mbox{[}libfuse\mbox{]}\+: \href{https://github.com/libfuse/libfuse}{\tt https\+://github.\+com/libfuse/libfuse}
\item \mbox{[}multithread\+\_\+mntapi\mbox{]}\+: multithread.\+png =600
\item \mbox{[}union\+\_\+mode\mbox{]}\+: union\+\_\+mode.\+png =600
\item \mbox{[}processcom\mbox{]}\+: process\+\_\+com.\+png =600
\item \mbox{[}fusemount\+I\+PC\mbox{]}\+: fusemount\+I\+P\+C.\+png =600
\end{DoxyEnumerate}

\mbox{[}mntapi\mbox{]}\+: mntapi.\+png =600 \char`\"{}mntapi\+\_\+orin\char`\"{}

\mbox{[}multithread\+\_\+mntapi\mbox{]}\+: multithread.\+png =600 \mbox{[}union\+\_\+mode\mbox{]}\+:union\+\_\+mode.\+png =400 \mbox{[}processcom\mbox{]}\+: process\+\_\+com.\+png =600 \mbox{[}fusemount\+I\+PC\mbox{]}\+: fusemount\+I\+P\+C.\+png =600 \mbox{[}fuse\mbox{]}\+: fuse.\+png =600 \mbox{[}fuse\+I\+P\+C\+\_\+timeline\mbox{]}\+: fuse\+I\+P\+C\+\_\+timeline.\+png =600 